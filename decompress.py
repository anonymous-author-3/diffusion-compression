import argparse
from lib.compression_args import add_compression_args
from PIL import Image
from lib.diffusion_models import get_diffuser_pipeline_components, get_finishing_scheduler
from lib.DDPM_compression import get_zipf_params, rcc_decode, denoise
import lib.compression_utils as utils
from pathlib import Path

from zipf_encoding import decode_zipf 
import yaml

parser = argparse.ArgumentParser(description="Compress an image using a diffusion model.")

parser.add_argument(
    '--config_path',
    type=str,
    default="configs/SD1.5-1KB.yaml",
    help="Path to the compression config .yaml file. Specifies details of how the image is encoded/decoded")

parser.add_argument(
    "--encoding_path",
    type=str,
    help="Path to the encoding generated by compress.py"
)
parser.add_argument(
    "--save_image_path",
    type=str,
    default='data/kodak/01.png',
    help="Path to save the decompressed image to."
)
parser.add_argument(
    "--image_width",
    type=int,
    default=768
)
parser.add_argument(
    "--image_height",
    type=int,
    default=512
)

parser.add_argument(
    '--finishing_scheduler',
    type=str,
    default='pndm',
    help="either pndm or ddpm. PNDM gets better PSNRs, DDPM seems to produce more naturalistic images, although this may be some mistake."
)

args = parser.parse_args()
with open(args.config_path, 'r') as file:
    config = yaml.safe_load(file)

model, encode_img, decode_img, ddpm_scheduler = get_diffuser_pipeline_components(config['model_str'], config['scheduler_timesteps'])

encoding_bytes = utils.load_bytes(args.encoding_path)

computed_chunk_sizes, zipf_s_vals, zipf_n_vals = get_zipf_params(config['D_kl_per_step'], config['max_chunk_size'], config['chunk_padding_bits'])

seeds = decode_zipf(zipf_s_vals, zipf_n_vals, encoding_bytes)

noisy_recontruction = rcc_decode(
    model,
    ddpm_scheduler,
    seeds,
    computed_chunk_sizes,
    sample_shape = (args.image_height, args.image_width)
)

finishing_scheduler = get_finishing_scheduler(config['model_str'], args.finishing_scheduler)

noisy_timestep = config['scheduler_timesteps'][-1]

denoised_recontruction = denoise(
    noisy_recontruction,
    noisy_timestep,
    model,
    finishing_scheduler
)

recon_pt = decode_img(denoised_recontruction)
recon_np = (utils.torch_to_np_img(recon_pt))
recon_pil = Image.fromarray(recon_np)

save_image_path = Path(args.save_image_path)
save_image_path.parent.mkdir(parents=True, exist_ok=True)

recon_pil.save(save_image_path)